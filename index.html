<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sinogram Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1400px;
            width: 100%;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
        }
        .content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        .left-panel {
            flex: 1;
            min-width: 300px;
        }
        .right-panel {
            flex: 1;
            min-width: 300px;
        }
        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .control-group h3 {
            margin-bottom: 15px;
            color: #555;
        }
        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        input[type="number"] {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 80px;
            font-size: 14px;
        }
        input[type="color"] {
            width: 50px;
            height: 38px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        select {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }
        .btn-add {
            background: #4CAF50;
            color: white;
        }
        .btn-add:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        .btn-draw {
            background: #2196F3;
            color: white;
            width: 100%;
            font-size: 16px;
            padding: 15px;
        }
        .btn-draw:hover {
            background: #0b7dda;
            transform: translateY(-2px);
        }
        .btn-clear {
            background: #f44336;
            color: white;
            width: 100%;
            margin-top: 10px;
        }
        .btn-clear:hover {
            background: #da190b;
        }
        .canvas-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 20px;
        }
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #ccc;
        }
        .points-list {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        .point-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .point-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        .info-text {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            line-height: 1.5;
        }
        .shape-controls {
            display: none;
        }
        .shape-controls.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Interactive Sinogram Visualizer</h1>
        
        <div class="content">
            <div class="left-panel">
                <div class="control-group">
                    <h3>Add Objects</h3>
                    <div class="input-row">
                        <select id="shapeType" onchange="updateShapeControls()">
                            <option value="point">Point</option>
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                            <option value="triangle">Equilateral Triangle</option>
                        </select>
                        <input type="color" id="objectColor" value="#ff0000">
                    </div>
                    
                    <div id="pointControls" class="shape-controls active">
                        <div class="input-row">
                            <input type="number" id="xCoord" placeholder="X" min="-5" max="5" step="0.5" value="0">
                            <input type="number" id="yCoord" placeholder="Y" min="-5" max="5" step="0.5" value="0">
                            <button class="btn-add" onclick="addObject()">Add Point</button>
                        </div>
                    </div>
                    
                    <div id="circleControls" class="shape-controls">
                        <div class="input-row">
                            <input type="number" id="circleCenterX" placeholder="Center X" min="-5" max="5" step="0.5" value="0">
                            <input type="number" id="circleCenterY" placeholder="Center Y" min="-5" max="5" step="0.5" value="0">
                        </div>
                        <div class="input-row">
                            <input type="number" id="circleRadius" placeholder="Radius" min="0.5" max="5" step="0.5" value="1">
                            <button class="btn-add" onclick="addObject()">Add Circle</button>
                        </div>
                    </div>
                    
                    <div id="squareControls" class="shape-controls">
                        <div class="input-row">
                            <input type="number" id="squareCenterX" placeholder="Center X" min="-5" max="5" step="0.5" value="0">
                            <input type="number" id="squareCenterY" placeholder="Center Y" min="-5" max="5" step="0.5" value="0">
                        </div>
                        <div class="input-row">
                            <input type="number" id="squareSide" placeholder="Side Length" min="0.5" max="10" step="0.5" value="2">
                            <button class="btn-add" onclick="addObject()">Add Square</button>
                        </div>
                    </div>
                    
                    <div id="triangleControls" class="shape-controls">
                        <div class="input-row">
                            <input type="number" id="triangleCenterX" placeholder="Center X" min="-5" max="5" step="0.5" value="0">
                            <input type="number" id="triangleCenterY" placeholder="Center Y" min="-5" max="5" step="0.5" value="0">
                        </div>
                        <div class="input-row">
                            <input type="number" id="triangleSide" placeholder="Side Length" min="0.5" max="10" step="0.5" value="2">
                            <button class="btn-add" onclick="addObject()">Add Triangle</button>
                        </div>
                    </div>
                    
                    <div class="info-text">
                        Coordinates range: X and Y from -5 to 5<br>
                        Center of grid is (0, 0)<br>
                        Triangle: one vertex points upward
                    </div>
                </div>

                <div class="control-group">
                    <h3>Added Objects</h3>
                    <div class="points-list" id="pointsList"></div>
                </div>

                <div class="control-group">
                    <button class="btn-draw" onclick="drawSinogram()">üìä Draw Sinogram</button>
                    <button class="btn-clear" onclick="clearAll()">üóëÔ∏è Clear All</button>
                </div>

                <div class="canvas-container">
                    <h3 style="text-align: center; margin-bottom: 10px;">Grid View</h3>
                    <canvas id="gridCanvas" width="400" height="400"></canvas>
                </div>
            </div>

            <div class="right-panel">
                <div class="canvas-container">
                    <h3 style="text-align: center; margin-bottom: 10px;">Sinogram (Œ∏: 0¬∞ to 180¬∞)</h3>
                    <canvas id="sinogramCanvas" width="600" height="600"></canvas>
                    <div class="info-text" style="text-align: center;">
                        Œ∏ = 0¬∞ corresponds to projection from Y-axis<br>
                        Vertical axis: Œ∏ (angle in degrees) | Horizontal axis: œÅ (projection distance)
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const objects = [];
        const gridSize = 10;
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const sinogramCanvas = document.getElementById('sinogramCanvas');
        const sinogramCtx = sinogramCanvas.getContext('2d');

        function updateShapeControls() {
            const shapeType = document.getElementById('shapeType').value;
            document.querySelectorAll('.shape-controls').forEach(el => el.classList.remove('active'));
            document.getElementById(shapeType + 'Controls').classList.add('active');
        }

        function drawGrid() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            
            const cellSize = gridCanvas.width / gridSize;
            const centerX = gridCanvas.width / 2;
            const centerY = gridCanvas.height / 2;

            // Draw grid lines
            gridCtx.strokeStyle = '#ddd';
            gridCtx.lineWidth = 1;
            for (let i = 0; i <= gridSize; i++) {
                gridCtx.beginPath();
                gridCtx.moveTo(i * cellSize, 0);
                gridCtx.lineTo(i * cellSize, gridCanvas.height);
                gridCtx.stroke();
                
                gridCtx.beginPath();
                gridCtx.moveTo(0, i * cellSize);
                gridCtx.lineTo(gridCanvas.width, i * cellSize);
                gridCtx.stroke();
            }

            // Draw axes
            gridCtx.strokeStyle = '#000';
            gridCtx.lineWidth = 2;
            gridCtx.beginPath();
            gridCtx.moveTo(centerX, 0);
            gridCtx.lineTo(centerX, gridCanvas.height);
            gridCtx.stroke();
            gridCtx.beginPath();
            gridCtx.moveTo(0, centerY);
            gridCtx.lineTo(gridCanvas.width, centerY);
            gridCtx.stroke();

            // Draw axis labels
            gridCtx.fillStyle = '#000';
            gridCtx.font = '12px Arial';
            gridCtx.fillText('X', gridCanvas.width - 15, centerY - 5);
            gridCtx.fillText('Y', centerX + 5, 15);
            gridCtx.fillText('0', centerX + 5, centerY - 5);

            // Draw objects
            objects.forEach(obj => {
                gridCtx.strokeStyle = obj.color;
                gridCtx.fillStyle = obj.color;
                
                if (obj.type === 'point') {
                    const px = centerX + (obj.x * cellSize);
                    const py = centerY - (obj.y * cellSize);
                    gridCtx.beginPath();
                    gridCtx.arc(px, py, 6, 0, 2 * Math.PI);
                    gridCtx.fill();
                    gridCtx.strokeStyle = '#000';
                    gridCtx.lineWidth = 1;
                    gridCtx.stroke();
                } else if (obj.type === 'circle') {
                    const cx = centerX + (obj.centerX * cellSize);
                    const cy = centerY - (obj.centerY * cellSize);
                    const r = obj.radius * cellSize;
                    gridCtx.globalAlpha = 0.3;
                    gridCtx.beginPath();
                    gridCtx.arc(cx, cy, r, 0, 2 * Math.PI);
                    gridCtx.fill();
                    gridCtx.globalAlpha = 1;
                    gridCtx.lineWidth = 2;
                    gridCtx.stroke();
                } else if (obj.type === 'square') {
                    const cx = centerX + (obj.centerX * cellSize);
                    const cy = centerY - (obj.centerY * cellSize);
                    const side = obj.side * cellSize;
                    gridCtx.globalAlpha = 0.3;
                    gridCtx.fillRect(cx - side/2, cy - side/2, side, side);
                    gridCtx.globalAlpha = 1;
                    gridCtx.lineWidth = 2;
                    gridCtx.strokeRect(cx - side/2, cy - side/2, side, side);
                } else if (obj.type === 'triangle') {
                    const cx = centerX + (obj.centerX * cellSize);
                    const cy = centerY - (obj.centerY * cellSize);
                    const side = obj.side * cellSize;
                    const height = side * Math.sqrt(3) / 2;
                    
                    gridCtx.beginPath();
                    // Top vertex
                    gridCtx.moveTo(cx, cy - height * 2/3);
                    // Bottom right vertex
                    gridCtx.lineTo(cx + side/2, cy + height/3);
                    // Bottom left vertex
                    gridCtx.lineTo(cx - side/2, cy + height/3);
                    gridCtx.closePath();
                    
                    gridCtx.globalAlpha = 0.3;
                    gridCtx.fill();
                    gridCtx.globalAlpha = 1;
                    gridCtx.lineWidth = 2;
                    gridCtx.stroke();
                }
            });
        }

        function addObject() {
            const shapeType = document.getElementById('shapeType').value;
            const color = document.getElementById('objectColor').value;

            if (shapeType === 'point') {
                const x = parseFloat(document.getElementById('xCoord').value);
                const y = parseFloat(document.getElementById('yCoord').value);
                
                if (isNaN(x) || isNaN(y)) {
                    alert('Please enter valid coordinates');
                    return;
                }
                if (x < -5 || x > 5 || y < -5 || y > 5) {
                    alert('Coordinates must be between -5 and 5');
                    return;
                }
                
                objects.push({ type: 'point', x, y, color });
            } else if (shapeType === 'circle') {
                const centerX = parseFloat(document.getElementById('circleCenterX').value);
                const centerY = parseFloat(document.getElementById('circleCenterY').value);
                const radius = parseFloat(document.getElementById('circleRadius').value);
                
                if (isNaN(centerX) || isNaN(centerY) || isNaN(radius)) {
                    alert('Please enter valid values');
                    return;
                }
                
                objects.push({ type: 'circle', centerX, centerY, radius, color });
            } else if (shapeType === 'square') {
                const centerX = parseFloat(document.getElementById('squareCenterX').value);
                const centerY = parseFloat(document.getElementById('squareCenterY').value);
                const side = parseFloat(document.getElementById('squareSide').value);
                
                if (isNaN(centerX) || isNaN(centerY) || isNaN(side)) {
                    alert('Please enter valid values');
                    return;
                }
                
                objects.push({ type: 'square', centerX, centerY, side, color });
            } else if (shapeType === 'triangle') {
                const centerX = parseFloat(document.getElementById('triangleCenterX').value);
                const centerY = parseFloat(document.getElementById('triangleCenterY').value);
                const side = parseFloat(document.getElementById('triangleSide').value);
                
                if (isNaN(centerX) || isNaN(centerY) || isNaN(side)) {
                    alert('Please enter valid values');
                    return;
                }
                
                objects.push({ type: 'triangle', centerX, centerY, side, color });
            }

            updateObjectsList();
            drawGrid();
        }

        function updateObjectsList() {
            const listDiv = document.getElementById('pointsList');
            listDiv.innerHTML = '';
            
            objects.forEach((obj, index) => {
                const item = document.createElement('div');
                item.className = 'point-item';
                let desc = '';
                if (obj.type === 'point') {
                    desc = `Point (${obj.x.toFixed(1)}, ${obj.y.toFixed(1)})`;
                } else if (obj.type === 'circle') {
                    desc = `Circle center:(${obj.centerX.toFixed(1)}, ${obj.centerY.toFixed(1)}) r:${obj.radius.toFixed(1)}`;
                } else if (obj.type === 'square') {
                    desc = `Square center:(${obj.centerX.toFixed(1)}, ${obj.centerY.toFixed(1)}) side:${obj.side.toFixed(1)}`;
                } else if (obj.type === 'triangle') {
                    desc = `Triangle center:(${obj.centerX.toFixed(1)}, ${obj.centerY.toFixed(1)}) side:${obj.side.toFixed(1)}`;
                }
                item.innerHTML = `
                    <div class="point-color" style="background-color: ${obj.color}"></div>
                    <span>${desc}</span>
                `;
                listDiv.appendChild(item);
            });
        }

        function getObjectPoints(obj) {
            const points = [];
            if (obj.type === 'point') {
                points.push({ x: obj.x, y: obj.y });
            } else if (obj.type === 'circle') {
                const numPoints = 100;
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * 2 * Math.PI;
                    points.push({
                        x: obj.centerX + obj.radius * Math.cos(angle),
                        y: obj.centerY + obj.radius * Math.sin(angle)
                    });
                }
            } else if (obj.type === 'square') {
                const half = obj.side / 2;
                const step = 0.1;
                for (let x = -half; x <= half; x += step) {
                    points.push({ x: obj.centerX + x, y: obj.centerY + half });
                    points.push({ x: obj.centerX + x, y: obj.centerY - half });
                }
                for (let y = -half; y <= half; y += step) {
                    points.push({ x: obj.centerX - half, y: obj.centerY + y });
                    points.push({ x: obj.centerX + half, y: obj.centerY + y });
                }
            } else if (obj.type === 'triangle') {
                const side = obj.side;
                const height = side * Math.sqrt(3) / 2;
                const step = 0.1;
                
                // Three vertices of equilateral triangle (top vertex pointing up)
                const v1 = { x: obj.centerX, y: obj.centerY + height * 2/3 };
                const v2 = { x: obj.centerX + side/2, y: obj.centerY - height/3 };
                const v3 = { x: obj.centerX - side/2, y: obj.centerY - height/3 };
                
                // Edge from v1 to v2
                for (let t = 0; t <= 1; t += step / side) {
                    points.push({
                        x: v1.x + t * (v2.x - v1.x),
                        y: v1.y + t * (v2.y - v1.y)
                    });
                }
                // Edge from v2 to v3
                for (let t = 0; t <= 1; t += step / side) {
                    points.push({
                        x: v2.x + t * (v3.x - v2.x),
                        y: v2.y + t * (v3.y - v2.y)
                    });
                }
                // Edge from v3 to v1
                for (let t = 0; t <= 1; t += step / side) {
                    points.push({
                        x: v3.x + t * (v1.x - v3.x),
                        y: v3.y + t * (v1.y - v3.y)
                    });
                }
            }
            return points;
        }

        function drawSinogram() {
            if (objects.length === 0) {
                alert('Please add at least one object first');
                return;
            }

            sinogramCtx.clearRect(0, 0, sinogramCanvas.width, sinogramCanvas.height);
            
            sinogramCtx.fillStyle = '#f8f9fa';
            sinogramCtx.fillRect(0, 0, sinogramCanvas.width, sinogramCanvas.height);

            const numAngles = 180;
            const maxRho = Math.sqrt(5*5 + 5*5) * 2;
            
            const margin = 60;
            const plotWidth = sinogramCanvas.width - 2 * margin;
            const plotHeight = sinogramCanvas.height - 2 * margin;
            
            // Draw axis lines
            sinogramCtx.strokeStyle = '#000';
            sinogramCtx.lineWidth = 2;
            sinogramCtx.beginPath();
            sinogramCtx.moveTo(margin, margin);
            sinogramCtx.lineTo(margin, margin + plotHeight);
            sinogramCtx.lineTo(margin + plotWidth, margin + plotHeight);
            sinogramCtx.stroke();
            
            // Draw œÅ = 0 line (vertical line at center)
            sinogramCtx.strokeStyle = '#666';
            sinogramCtx.lineWidth = 1;
            sinogramCtx.setLineDash([5, 5]);
            sinogramCtx.beginPath();
            sinogramCtx.moveTo(margin + plotWidth / 2, margin);
            sinogramCtx.lineTo(margin + plotWidth / 2, margin + plotHeight);
            sinogramCtx.stroke();
            sinogramCtx.setLineDash([]);
            
            // Label œÅ = 0
            sinogramCtx.fillStyle = '#666';
            sinogramCtx.font = '11px Arial';
            sinogramCtx.fillText('œÅ=0', margin + plotWidth / 2 - 12, margin + plotHeight + 20);

            // Labels
            sinogramCtx.fillStyle = '#000';
            sinogramCtx.font = '14px Arial';
            sinogramCtx.fillText('œÅ', margin + plotWidth / 2, sinogramCanvas.height - 10);
            sinogramCtx.save();
            sinogramCtx.translate(15, margin + plotHeight / 2);
            sinogramCtx.rotate(-Math.PI / 2);
            sinogramCtx.fillText('Œ∏ (degrees)', 0, 0);
            sinogramCtx.restore();

            // Draw theta markers (vertical axis) - reversed from 180 at top to 0 at bottom
            sinogramCtx.font = '11px Arial';
            for (let i = 0; i <= 6; i++) {
                const y = margin + (i / 6) * plotHeight;
                const theta = 180 - (i / 6) * 180;  // Reversed: 180 at top, 0 at bottom
                sinogramCtx.fillText(theta.toFixed(0) + '¬∞', 10, y + 4);
            }

            // Draw rho markers (horizontal axis)
            for (let i = 0; i <= 4; i++) {
                const x = margin + (i / 4) * plotWidth;
                const rho = -maxRho + (i / 4) * 2 * maxRho;
                sinogramCtx.fillText(rho.toFixed(1), x - 15, sinogramCanvas.height - 25);
            }

            // Calculate and draw sinogram with reversed theta
            objects.forEach(obj => {
                const points = getObjectPoints(obj);
                
                sinogramCtx.strokeStyle = obj.color;
                sinogramCtx.lineWidth = 2;
                
                for (let i = 0; i < numAngles; i++) {
                    const theta = (i / (numAngles - 1)) * Math.PI;
                    
                    points.forEach(point => {
                        const rho = point.x * Math.cos(theta) + point.y * Math.sin(theta);
                        
                        // Map to canvas coordinates (theta vertical reversed, rho horizontal)
                        // Reverse theta: 0 degrees at bottom, 180 at top
                        const canvasY = margin + plotHeight - (theta / Math.PI) * plotHeight;
                        const canvasX = margin + plotWidth / 2 + (rho / maxRho) * plotWidth / 2;
                        
                        sinogramCtx.fillStyle = obj.color;
                        sinogramCtx.fillRect(canvasX - 1, canvasY - 1, 2, 2);
                    });
                }
            });
        }

        function clearAll() {
            objects.length = 0;
            updateObjectsList();
            drawGrid();
            sinogramCtx.clearRect(0, 0, sinogramCanvas.width, sinogramCanvas.height);
        }

        // Initialize
        drawGrid();
    </script>
</body>

</html>
