<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicle Detection & Tracking</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .demo-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            color: white;
            text-align: center;
        }

        .demo-section h2 {
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .demo-section p {
            margin-bottom: 20px;
            opacity: 0.95;
        }

        .upload-section {
            background: #fff;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 2px dashed #667eea;
            text-align: center;
        }

        .upload-section h2 {
            color: #333;
            margin-bottom: 20px;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px;
            font-weight: 600;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .video-container {
            position: relative;
            margin: 20px 0;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            display: none;
            max-width: 100%;
        }

        .video-container.active {
            display: block;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            display: inline-block;
        }

        video {
            display: none;
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 12px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 20px 0;
            display: none;
        }

        .stats.active {
            display: grid;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card h3 {
            font-size: 0.9em;
            margin-bottom: 10px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card .number {
            font-size: 2.5em;
            font-weight: bold;
        }

        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            display: none;
            font-weight: 500;
        }

        .status.active {
            display: block;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #d32f2f;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }

        .loader.active {
            display: block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info-box {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .info-box h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .info-box ul {
            margin-left: 20px;
            color: #666;
            line-height: 1.8;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
            display: none;
        }

        .controls.active {
            display: block;
        }

        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöó AI Vehicle Detection & Tracking</h1>
        <p class="subtitle">Real-time vehicle detection powered by YOLOv8 ONNX</p>

        <div class="demo-section">
            <h2>üé¨ Try Live Demo</h2>
            <p>Experience real-time vehicle detection on a sample traffic video</p>
            <button class="btn" id="demoBtn" disabled>‚ñ∂ Run Live Demo</button>
        </div>

        <div class="upload-section">
            <h2>üì§ Upload Your Own Video</h2>
            <input type="file" id="videoInput" accept="video/*">
            <button class="btn" onclick="document.getElementById('videoInput').click()">
                Choose Video File
            </button>
            <p style="margin-top: 15px; color: #666;">Supported: MP4, WebM, MOV</p>
        </div>

        <div class="status" id="status"></div>
        <div class="loader" id="loader"></div>

        <div class="stats" id="statsContainer">
            <div class="stat-card">
                <h3>üöó Cars</h3>
                <div class="number" id="carCount">0</div>
            </div>
            <div class="stat-card">
                <h3>üöå Buses</h3>
                <div class="number" id="busCount">0</div>
            </div>
            <div class="stat-card">
                <h3>üöö Trucks</h3>
                <div class="number" id="truckCount">0</div>
            </div>
            <div class="stat-card">
                <h3>üèçÔ∏è Motorcycles</h3>
                <div class="number" id="motorcycleCount">0</div>
            </div>
            <div class="stat-card">
                <h3>üìä Total</h3>
                <div class="number" id="totalCount">0</div>
            </div>
        </div>

        <div class="video-container" id="videoContainer">
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
                <div class="fps-counter" id="fpsCounter">FPS: 0</div>
            </div>
        </div>

        <div class="controls" id="controls">
            <button class="btn btn-secondary" id="pauseBtn">‚è∏ Pause</button>
            <button class="btn btn-secondary" id="resetBtn">üîÑ Reset</button>
        </div>

        <video id="video" style="display: none;" muted playsinline crossorigin="anonymous"></video>

        <div class="info-box">
            <h3>‚ÑπÔ∏è System Features:</h3>
            <ul>
                <li><strong>YOLOv8n ONNX Model</strong> - Ultra-fast object detection optimized for web</li>
                <li><strong>IoU-Based Tracking</strong> - Intelligent tracking prevents double counting</li>
                <li><strong>Real-time Processing</strong> - Live detection with FPS counter</li>
                <li><strong>Multi-Vehicle Support</strong> - Detects cars, buses, trucks, and motorcycles</li>
                <li><strong>Browser-Based</strong> - All processing happens locally, no server needed</li>
                <li><strong>Privacy First</strong> - Your videos never leave your device</li>
            </ul>
        </div>

        <div class="info-box" style="border-left-color: #ff6b6b;">
            <h3>‚ö†Ô∏è Setup Required:</h3>
            <ul>
                <li><strong>Model File Needed:</strong> Download YOLOv8n ONNX model from <a href="https://github.com/ultralytics/assets/releases" target="_blank">Ultralytics GitHub</a></li>
                <li><strong>Instructions:</strong> Look for "yolov8n.onnx" (smallest, fastest model ~6MB)</li>
                <li><strong>Alternative:</strong> Host the model file and update MODEL_URL in the code</li>
                <li><strong>Current Status:</strong> Using simulated detection until real model is loaded</li>
            </ul>
        </div>
    </div>

    <script>
        // YOLO class names (COCO dataset)
        const YOLO_CLASSES = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
            'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
            'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
            'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard',
            'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch',
            'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard',
            'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase',
            'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        const VEHICLE_CLASSES = {
            2: 'car',
            3: 'motorcycle', 
            5: 'bus',
            7: 'truck'
        };

        const INPUT_SIZE = 640;
        const CONFIDENCE_THRESHOLD = 0.5;
        const IOU_THRESHOLD = 0.45;
        const NMS_THRESHOLD = 0.45;
        const MAX_FRAMES_MISSING = 15;

        // Model URL - You need to host your own YOLOv8 ONNX model
        const MODEL_URL = 'yolov8n.onnx'; // Update this with your model path

        let session = null;
        let videoElement = document.getElementById('video');
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let isProcessing = false;
        let isPaused = false;
        let animationId = null;
        let modelLoaded = false;

        // Tracking system
        let trackedVehicles = new Map();
        let nextId = 1;
        let vehicleCounts = {
            car: new Set(),
            bus: new Set(),
            truck: new Set(),
            motorcycle: new Set()
        };

        // FPS calculation
        let lastFrameTime = Date.now();
        let fps = 0;

        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status active ' + type;
        }

        function showLoader(show) {
            document.getElementById('loader').className = show ? 'loader active' : 'loader';
        }

        async function loadModel() {
            showStatus('üîÑ Loading YOLOv8 model...', 'info');
            showLoader(true);
            
            try {
                session = await ort.InferenceSession.create(MODEL_URL, {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });
                
                modelLoaded = true;
                showStatus('‚úÖ Model loaded successfully! Ready to detect vehicles.', 'success');
                showLoader(false);
                document.getElementById('demoBtn').disabled = false;
                
                return true;
            } catch (error) {
                console.error('Model loading error:', error);
                showStatus('‚ö†Ô∏è Could not load ONNX model. Using fallback detection. See setup instructions below.', 'warning');
                showLoader(false);
                document.getElementById('demoBtn').disabled = false;
                modelLoaded = false;
                return false;
            }
        }

        function preprocessImage(imageData) {
            const { data, width, height } = imageData;
            const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
            
            // Resize and normalize
            for (let c = 0; c < 3; c++) {
                for (let y = 0; y < INPUT_SIZE; y++) {
                    for (let x = 0; x < INPUT_SIZE; x++) {
                        const srcX = Math.floor(x * width / INPUT_SIZE);
                        const srcY = Math.floor(y * height / INPUT_SIZE);
                        const srcIdx = (srcY * width + srcX) * 4;
                        const dstIdx = c * INPUT_SIZE * INPUT_SIZE + y * INPUT_SIZE + x;
                        input[dstIdx] = data[srcIdx + c] / 255.0;
                    }
                }
            }
            
            return input;
        }

        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

            const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;

            return union > 0 ? intersection / union : 0;
        }

        function nonMaxSuppression(boxes, threshold) {
            boxes.sort((a, b) => b.confidence - a.confidence);
            const selected = [];

            while (boxes.length > 0) {
                const current = boxes.shift();
                selected.push(current);

                boxes = boxes.filter(box => {
                    if (box.classId !== current.classId) return true;
                    return calculateIoU(current, box) < threshold;
                });
            }

            return selected;
        }

        function postprocessOutput(output, imgWidth, imgHeight) {
            const boxes = [];
            const [batchSize, dimensions, numBoxes] = output.dims;
            const data = output.data;

            const scaleX = imgWidth / INPUT_SIZE;
            const scaleY = imgHeight / INPUT_SIZE;

            for (let i = 0; i < numBoxes; i++) {
                const offset = i * dimensions;
                
                const x = data[offset + 0];
                const y = data[offset + 1];
                const w = data[offset + 2];
                const h = data[offset + 3];

                let maxConf = 0;
                let maxClass = -1;

                for (let c = 4; c < dimensions; c++) {
                    if (data[offset + c] > maxConf) {
                        maxConf = data[offset + c];
                        maxClass = c - 4;
                    }
                }

                if (maxConf > CONFIDENCE_THRESHOLD && VEHICLE_CLASSES[maxClass]) {
                    boxes.push({
                        x: (x - w / 2) * scaleX,
                        y: (y - h / 2) * scaleY,
                        width: w * scaleX,
                        height: h * scaleY,
                        confidence: maxConf,
                        classId: maxClass,
                        type: VEHICLE_CLASSES[maxClass]
                    });
                }
            }

            return nonMaxSuppression(boxes, NMS_THRESHOLD);
        }

        function trackVehicle(detection, vehicleType) {
            let bestMatch = null;
            let bestIoU = IOU_THRESHOLD;

            for (let [id, tracked] of trackedVehicles.entries()) {
                if (tracked.type === vehicleType) {
                    const iou = calculateIoU(detection, tracked.bbox);
                    if (iou > bestIoU) {
                        bestIoU = iou;
                        bestMatch = id;
                    }
                }
            }

            if (bestMatch) {
                trackedVehicles.get(bestMatch).bbox = detection;
                trackedVehicles.get(bestMatch).framesMissing = 0;
                return bestMatch;
            } else {
                const newId = nextId++;
                trackedVehicles.set(newId, {
                    type: vehicleType,
                    bbox: detection,
                    framesMissing: 0
                });
                vehicleCounts[vehicleType].add(newId);
                return newId;
            }
        }

        function updateTracking() {
            for (let [id, tracked] of trackedVehicles.entries()) {
                tracked.framesMissing++;
                if (tracked.framesMissing > MAX_FRAMES_MISSING) {
                    trackedVehicles.delete(id);
                }
            }
        }

        function updateStats() {
            document.getElementById('carCount').textContent = vehicleCounts.car.size;
            document.getElementById('busCount').textContent = vehicleCounts.bus.size;
            document.getElementById('truckCount').textContent = vehicleCounts.truck.size;
            document.getElementById('motorcycleCount').textContent = vehicleCounts.motorcycle.size;
            
            const total = vehicleCounts.car.size + vehicleCounts.bus.size + 
                         vehicleCounts.truck.size + vehicleCounts.motorcycle.size;
            document.getElementById('totalCount').textContent = total;
        }

        async function detectVehiclesInFrame() {
            if (!modelLoaded) {
                // Fallback to simulated detection
                return simulateDetection();
            }

            try {
                // Create a temporary canvas for preprocessing
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = INPUT_SIZE;
                tempCanvas.height = INPUT_SIZE;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.drawImage(videoElement, 0, 0, INPUT_SIZE, INPUT_SIZE);
                const imageData = tempCtx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
                
                // Preprocess
                const inputData = preprocessImage(imageData);
                const inputTensor = new ort.Tensor('float32', inputData, [1, 3, INPUT_SIZE, INPUT_SIZE]);
                
                // Run inference
                const feeds = { images: inputTensor };
                const results = await session.run(feeds);
                const output = results[Object.keys(results)[0]];
                
                // Postprocess
                return postprocessOutput(output, videoElement.videoWidth, videoElement.videoHeight);
            } catch (error) {
                console.error('Detection error:', error);
                return [];
            }
        }

        function simulateDetection() {
            // Fallback simulated detection
            const detections = [];
            const time = videoElement.currentTime;
            const numVehicles = 2 + Math.floor(Math.random() * 2);
            
            for (let i = 0; i < numVehicles; i++) {
                const vehicleTypes = ['car', 'bus', 'truck', 'motorcycle'];
                const type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
                
                const x = (canvas.width * 0.1) + ((time * 50 + i * 200) % (canvas.width * 0.8));
                const y = canvas.height * 0.3 + Math.sin(time + i) * 100 + (i * 80);
                const width = type === 'bus' || type === 'truck' ? 120 : 80;
                const height = type === 'bus' || type === 'truck' ? 80 : 60;
                
                detections.push({
                    type: type,
                    x, y, width, height,
                    confidence: 0.85 + Math.random() * 0.15,
                    classId: Object.keys(VEHICLE_CLASSES).find(k => VEHICLE_CLASSES[k] === type)
                });
            }
            
            return detections;
        }

        function drawDetections(detections) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            
            detections.forEach(detection => {
                const bbox = { x: detection.x, y: detection.y, width: detection.width, height: detection.height };
                const vehicleId = trackVehicle(bbox, detection.type);
                
                const colors = {
                    car: '#00ff00',
                    bus: '#ff00ff',
                    truck: '#00ffff',
                    motorcycle: '#ffff00'
                };
                
                ctx.strokeStyle = colors[detection.type] || '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(detection.x, detection.y, detection.width, detection.height);
                
                const label = `${detection.type} #${vehicleId} (${(detection.confidence * 100).toFixed(0)}%)`;
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = 'bold 16px Arial';
                
                const textWidth = ctx.measureText(label).width;
                ctx.fillRect(detection.x, detection.y - 25, textWidth + 10, 25);
                
                ctx.fillStyle = '#000';
                ctx.fillText(label, detection.x + 5, detection.y - 7);
            });
        }

        function updateFPS() {
            const now = Date.now();
            fps = Math.round(1000 / (now - lastFrameTime));
            lastFrameTime = now;
            document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
        }

        async function processFrame() {
            if (!isProcessing || isPaused) {
                if (isProcessing && isPaused) {
                    animationId = requestAnimationFrame(processFrame);
                }
                return;
            }

            try {
                updateTracking();
                const detections = await detectVehiclesInFrame();
                drawDetections(detections);
                updateStats();
                updateFPS();

                if (!videoElement.paused && !videoElement.ended) {
                    animationId = requestAnimationFrame(processFrame);
                } else if (videoElement.ended) {
                    showStatus('‚úÖ Processing complete!', 'success');
                    document.getElementById('controls').classList.remove('active');
                }
            } catch (error) {
                console.error('Frame processing error:', error);
            }
        }

        function resetTracking() {
            trackedVehicles.clear();
            nextId = 1;
            vehicleCounts = {
                car: new Set(),
                bus: new Set(),
                truck: new Set(),
                motorcycle: new Set()
            };
            updateStats();
        }

        async function startProcessing(videoSrc) {
            if (isProcessing) {
                stopProcessing();
            }

            resetTracking();
            isProcessing = true;
            isPaused = false;

            videoElement.src = videoSrc;
            
            await new Promise((resolve) => {
                videoElement.onloadedmetadata = () => {
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                    resolve();
                };
            });

            document.getElementById('videoContainer').classList.add('active');
            document.getElementById('statsContainer').classList.add('active');
            document.getElementById('controls').classList.add('active');
            
            if (modelLoaded) {
                showStatus('üé¨ Processing video with AI model...', 'info');
            } else {
                showStatus('üé¨ Processing video with simulated detection (model not loaded)...', 'warning');
            }

            videoElement.play();
            processFrame();
        }

        function stopProcessing() {
            isProcessing = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (videoElement) {
                videoElement.pause();
            }
        }

        // Event Listeners
        document.getElementById('demoBtn').addEventListener('click', async () => {
            const sampleVideo = 'https://www.w3schools.com/html/mov_bbb.mp4';
            await startProcessing(sampleVideo);
        });

        document.getElementById('videoInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const videoURL = URL.createObjectURL(file);
                await startProcessing(videoURL);
            }
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                videoElement.pause();
                btn.textContent = '‚ñ∂ Resume';
            } else {
                videoElement.play();
                btn.textContent = '‚è∏ Pause';
                processFrame();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            stopProcessing();
            resetTracking();
            videoElement.currentTime = 0;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            showStatus('üîÑ Reset complete. Ready for new video.', 'info');
        });

        // Initialize
        loadModel();
    </script>
</body>
</html>
